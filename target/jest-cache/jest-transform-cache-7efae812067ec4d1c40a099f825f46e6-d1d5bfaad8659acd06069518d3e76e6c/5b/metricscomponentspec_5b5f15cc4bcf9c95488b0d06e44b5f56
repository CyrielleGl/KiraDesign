547d1d0201f576f006e199e14b32933c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@angular/core/testing");
const rxjs_1 = require("rxjs");
const test_module_1 = require("../../../test.module");
const metrics_component_1 = require("app/admin/metrics/metrics.component");
const metrics_service_1 = require("app/admin/metrics/metrics.service");
describe('Component Tests', () => {
    describe('MetricsComponent', () => {
        let comp;
        let fixture;
        let service;
        beforeEach(testing_1.async(() => {
            testing_1.TestBed.configureTestingModule({
                imports: [test_module_1.KiraTestModule],
                declarations: [metrics_component_1.MetricsComponent],
            })
                .overrideTemplate(metrics_component_1.MetricsComponent, '')
                .compileComponents();
        }));
        beforeEach(() => {
            fixture = testing_1.TestBed.createComponent(metrics_component_1.MetricsComponent);
            comp = fixture.componentInstance;
            service = fixture.debugElement.injector.get(metrics_service_1.MetricsService);
        });
        describe('refresh', () => {
            it('should call refresh on init', () => {
                // GIVEN
                const response = {
                    timers: {
                        service: 'test',
                        unrelatedKey: 'test',
                    },
                    gauges: {
                        'jcache.statistics': {
                            value: 2,
                        },
                        unrelatedKey: 'test',
                    },
                };
                spyOn(service, 'getMetrics').and.returnValue(rxjs_1.of(response));
                // WHEN
                comp.ngOnInit();
                // THEN
                expect(service.getMetrics).toHaveBeenCalled();
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiRDpcXDEuUFJPR1JBTU1BVElPTlxcSkhJUFNURVJcXGtpcmFcXHNyY1xcdGVzdFxcamF2YXNjcmlwdFxcc3BlY1xcYXBwXFxhZG1pblxcbWV0cmljc1xcbWV0cmljcy5jb21wb25lbnQuc3BlYy50cyIsIm1hcHBpbmdzIjoiOztBQUFBLG1EQUF5RTtBQUN6RSwrQkFBMEI7QUFFMUIsc0RBQXNEO0FBQ3RELDJFQUF1RTtBQUN2RSx1RUFBbUU7QUFFbkUsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtJQUMvQixRQUFRLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFO1FBQ2hDLElBQUksSUFBc0IsQ0FBQztRQUMzQixJQUFJLE9BQTJDLENBQUM7UUFDaEQsSUFBSSxPQUF1QixDQUFDO1FBRTVCLFVBQVUsQ0FBQyxlQUFLLENBQUMsR0FBRyxFQUFFO1lBQ3BCLGlCQUFPLENBQUMsc0JBQXNCLENBQUM7Z0JBQzdCLE9BQU8sRUFBRSxDQUFDLDRCQUFjLENBQUM7Z0JBQ3pCLFlBQVksRUFBRSxDQUFDLG9DQUFnQixDQUFDO2FBQ2pDLENBQUM7aUJBQ0MsZ0JBQWdCLENBQUMsb0NBQWdCLEVBQUUsRUFBRSxDQUFDO2lCQUN0QyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFSixVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ2QsT0FBTyxHQUFHLGlCQUFPLENBQUMsZUFBZSxDQUFDLG9DQUFnQixDQUFDLENBQUM7WUFDcEQsSUFBSSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztZQUNqQyxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLGdDQUFjLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFO1lBQ3ZCLEVBQUUsQ0FBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUU7Z0JBQ3JDLFFBQVE7Z0JBQ1IsTUFBTSxRQUFRLEdBQUc7b0JBQ2YsTUFBTSxFQUFFO3dCQUNOLE9BQU8sRUFBRSxNQUFNO3dCQUNmLFlBQVksRUFBRSxNQUFNO3FCQUNyQjtvQkFDRCxNQUFNLEVBQUU7d0JBQ04sbUJBQW1CLEVBQUU7NEJBQ25CLEtBQUssRUFBRSxDQUFDO3lCQUNUO3dCQUNELFlBQVksRUFBRSxNQUFNO3FCQUNyQjtpQkFDRixDQUFDO2dCQUNGLEtBQUssQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxTQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFFM0QsT0FBTztnQkFDUCxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBRWhCLE9BQU87Z0JBQ1AsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ2hELENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkQ6XFwxLlBST0dSQU1NQVRJT05cXEpISVBTVEVSXFxraXJhXFxzcmNcXHRlc3RcXGphdmFzY3JpcHRcXHNwZWNcXGFwcFxcYWRtaW5cXG1ldHJpY3NcXG1ldHJpY3MuY29tcG9uZW50LnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50Rml4dHVyZSwgVGVzdEJlZCwgYXN5bmMgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgS2lyYVRlc3RNb2R1bGUgfSBmcm9tICcuLi8uLi8uLi90ZXN0Lm1vZHVsZSc7XG5pbXBvcnQgeyBNZXRyaWNzQ29tcG9uZW50IH0gZnJvbSAnYXBwL2FkbWluL21ldHJpY3MvbWV0cmljcy5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWV0cmljc1NlcnZpY2UgfSBmcm9tICdhcHAvYWRtaW4vbWV0cmljcy9tZXRyaWNzLnNlcnZpY2UnO1xuXG5kZXNjcmliZSgnQ29tcG9uZW50IFRlc3RzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnTWV0cmljc0NvbXBvbmVudCcsICgpID0+IHtcbiAgICBsZXQgY29tcDogTWV0cmljc0NvbXBvbmVudDtcbiAgICBsZXQgZml4dHVyZTogQ29tcG9uZW50Rml4dHVyZTxNZXRyaWNzQ29tcG9uZW50PjtcbiAgICBsZXQgc2VydmljZTogTWV0cmljc1NlcnZpY2U7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jKCgpID0+IHtcbiAgICAgIFRlc3RCZWQuY29uZmlndXJlVGVzdGluZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtLaXJhVGVzdE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW01ldHJpY3NDb21wb25lbnRdLFxuICAgICAgfSlcbiAgICAgICAgLm92ZXJyaWRlVGVtcGxhdGUoTWV0cmljc0NvbXBvbmVudCwgJycpXG4gICAgICAgIC5jb21waWxlQ29tcG9uZW50cygpO1xuICAgIH0pKTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZml4dHVyZSA9IFRlc3RCZWQuY3JlYXRlQ29tcG9uZW50KE1ldHJpY3NDb21wb25lbnQpO1xuICAgICAgY29tcCA9IGZpeHR1cmUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICBzZXJ2aWNlID0gZml4dHVyZS5kZWJ1Z0VsZW1lbnQuaW5qZWN0b3IuZ2V0KE1ldHJpY3NTZXJ2aWNlKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdyZWZyZXNoJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjYWxsIHJlZnJlc2ggb24gaW5pdCcsICgpID0+IHtcbiAgICAgICAgLy8gR0lWRU5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgdGltZXJzOiB7XG4gICAgICAgICAgICBzZXJ2aWNlOiAndGVzdCcsXG4gICAgICAgICAgICB1bnJlbGF0ZWRLZXk6ICd0ZXN0JyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdhdWdlczoge1xuICAgICAgICAgICAgJ2pjYWNoZS5zdGF0aXN0aWNzJzoge1xuICAgICAgICAgICAgICB2YWx1ZTogMixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnJlbGF0ZWRLZXk6ICd0ZXN0JyxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzcHlPbihzZXJ2aWNlLCAnZ2V0TWV0cmljcycpLmFuZC5yZXR1cm5WYWx1ZShvZihyZXNwb25zZSkpO1xuXG4gICAgICAgIC8vIFdIRU5cbiAgICAgICAgY29tcC5uZ09uSW5pdCgpO1xuXG4gICAgICAgIC8vIFRIRU5cbiAgICAgICAgZXhwZWN0KHNlcnZpY2UuZ2V0TWV0cmljcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=